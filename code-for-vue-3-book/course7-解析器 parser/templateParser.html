<script>
  // 着手实现一个更加完善的`模板解析器`，解析器的基本架构模型如下：
  const TextModes = {
    DATA: "DATA",
    RCDATA: "RCDATA",
    RAWTEXT: "RAWTEXT",
    CDATA: "CDATA",
  };

  // 解析器函数，接收模板字符串作为参数
  function parse(str) {
    const context = {
      // source 是模板内容，用于在解析过程中进行消费
      source: str,
      // 解析器当前处于文本模式，初始模式为 DATA
      mode: TextModes.DATA,
      // advanceBy 函数用来消费指定数量的字符，它接收一个数字作为参数
      advanceBy(num) {
        context.source = context.source.slice(num);
      },
      // 匹配空白字符，调用 advanceBy 函数消费空白字符
      advanceSpaces() {
        const match = /^[\t\r\n\f ]+/.exec(context.source);
        if (match) {
          context.advanceBy(match[0].length);
        }
      },
    };
    // 返回解析后得到的子节点。
    const nodes = parseChildren(context, []);

    // 返回 root 根节点
    return {
      type: "Root",
      children: nodes,
    };
  }

  /**
   *  parseChildren 函数本质上也是一个状态机
   * 1. 标签节点，例如 <div>
   * 2. 文本插值节点，例如 {{ val }}
   * 3. 普通文本节点，例如 text
   * 4. 注释节点，例如 <!---->
   * 5. CDATA节点，例如 <!CDATA[xxx]>
   */

  // 第一个参数context，上下文对象
  // 第二个参数是由父代节点构成的节点栈，用于维护节点间的父子级关系，初始时栈为空
  function parseChildren(context, ancestors) {
    // 定义 nodes 数组存储子节点，它将作为最终的返回值
    let nodes = [];
    const { mode, source } = context;
    // 开启 while 循环，只要满足条件就会一直对字符串进行解析
    while (!isEnd(context, ancestors)) {
      let node;

      // 根据表 16-1可知，只有处于 DATA模式或RCDATA模式时，解析器才支持插值节点的解析
      // 并且，只有处于 DATA模式时，解析器才支持标签节点、注释节点、和CDATA节点的解析
      if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
        if (mode === TextModes.DATA && source[0] === "<") {
          if (source[1] === "!") {
            if (source.startsWith("<!--")) {
              // 注释
              node = parseComment(context);
            } else if (source.startsWith("<!CDATA")) {
              // CDATA
              node = parseCDATA(context);
            }
          } else if (source[1] === "/") {
            // 结束标签
            // 状态机遭遇了闭合标签，此时应该抛出错误，因为它缺少与之对应的开始标签
            console.error("无效的结束标签");
            continue;
          } else if (/[a-z]/i.test(source[1])) {
            //标签
            node = parseElement(context, ancestors);
          }
        } else if (source.startsWith("\{\{")) {
          // 解析插值
          node = parseInterpolation(context);
        }
      }

      // node 不存在，说明处于其他模式，即非 DATA模式且非RCDATA模式
      // 作为文本节点处理
      if (!node) {
        // 解析文本节点
        node = parseText(context);
      }

      nodes.push(node);
    }

    // 当 while 循环停止后，说明子节点解析完毕，返回子节点。
    return nodes;
  }

  /**
   * 我们知道了解析器会在何时开启新的状态机，以及状态机会在何时停止。
   * ❗❗结论：
   * 当解析器遇到开始标签时，会将该标签压入父级节点栈，同时开启新的状态机。
   * 当解析器遇到结束标签，并且父节点栈中存在与该标签同名的开始标签节点时，会停止当前正在运行的状态机
   */
  function isEnd(context, ancestors) {
    if (!context.source) {
      return true;
    }

    // 与父级节点栈内所有节点做比较，只要栈中存在于当前结束标签同名的节点，就停止状态机
    for (let i = ancestors.length - 1; i >= 0; i--) {
      if (context.source.startsWith(`</${ancestors[i].tag}`)) {
        return true;
      }
    }
  }

  /**
   * 解析这个： <span>哈哈哈</span>
   * parseElement 函数会做三件事：
   * ① 解析开始节点: parseTag
   * ② 解析子节点：parseChildren
   * ③ 解析结束标签：parseEndTag
   */
  function parseElement(context, ancestors) {
    const element = parseTag(context);
    if (element.isSelfClosing) {
      return element;
    }

    // 切换到正确的文本模式
    if (element.tag === "textarea" || element.tag === "title") {
      // 解析得到的标签是 <textarea> 或 <title>，则切换到 RCDATA模式
      context.mode = TextModes.RCDATA;
    } else if (/style|xmp|iframe|noembed|noframes|noscript/.test(element.tag)) {
      // 如果是 <style>、<xmp>、<iframe>、<noembed>、<noframes>、<noscript>则切换到 RAWTEXT
      context.mode = TextModes.RAWTEXT;
    } else {
      // 否则切换到 DATA 模式
      context.mode = TextModes.DATA;
    }

    ancestors.push(element);
    element.children = parseChildren(context, ancestors);
    ancestors.pop();

    if (context.source.startsWith(`</${element.tag}`)) {
      parseTag(context, "end");
    } else {
      console.error(`${element.tag} 标签缺少闭合标签`);
    }

    return element;
  }

  function parseTag(context, type = "start") {
    const { advanceBy, advanceSpaces } = context;
    // 匹配开始标签 (【字符<后面需要紧跟字母】【匹配非空白符，非空格，且非字符/和字符>】i:不区分大小写)
    // <div  >,匹配的结果是 ['<div','div']
    const startMatch = /^<([a-z][^\t\r\n\f />]*)/i;
    // 匹配结束标签
    const endMatch = /^<\/([a-z][^\t\r\n\f />]*)>/i;
    const match = type === "start" ? startMatch : endMatch;
    const matchResult = match.exec(context.source);
    // 标签名称,正则表达式的第一个捕获组的值
    const tag = matchResult[1];
    // 消费正则表达式匹配的全部内容，例如：'<div'
    advanceBy(matchResult[0].length);
    // 消费标签中无用的空白字符
    advanceSpaces();

    // <div id='foo' v-show="display" > 剩下的内容为： id='foo' v-show="display" >
    // 调用 parseAttributes 函数完成属性和指令的解析，并得到props数组，
    // props 数组是由指令节点和属性节点共同组成的数组
    const props = parseAttribute(context);

    //在消费匹配的内容后，如果字符串以 `/>`开头，则说明这是一个自闭合标签
    const isSelfClosing = context.source.startsWith("/>");
    // isSelfClosing 则消费 '/>',否则消费'>''
    advanceBy(isSelfClosing ? 2 : 1);

    return {
      type: "Element",
      tag,
      props,
      children: [],
      isSelfClosing,
    };
  }

  // <div id = "foo" v-show = "diaplay" >
  function parseAttribute(context) {
    const { advanceBy, advanceSpaces } = context;
    // 用来存储解析过程中产生的属性节点和指令节点
    const props = [];

    // 开启 while 循环，不断地消费模板内容，直至遇到标签的“结束部分”为止
    while (
      !context.source.startsWith(">") &&
      !context.source.startsWith("/>") &&
      context.source
    ) {
      // 匹配属性名称
      const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
      console.log("match---", context.source, match);
      // 获取属性名称
      const name = match[0];
      // 消费属性名称
      advanceBy(name.length);
      // 消费属性名称与等于号之间的空白字符
      advanceSpaces();
      // 消费等于号
      advanceBy(1);
      // 消费等于号与属性值之间的空白字符
      advanceSpaces();

      // 属性值
      let value = "";

      // 获取当前模板内容的第一个字符
      const quote = context.source[0];
      // 判断属性值是否被引号引用（单引号或者双引号）
      const isQuated = quote === '"' || quote === "'";

      if (isQuated) {
        // 属性值被引号引用，则消费引号
        advanceBy(1);
        // 获取下一个引号的索引
        const endQuoteIndex = context.source.indexOf(quote);
        if (endQuoteIndex > -1) {
          // 获取下一个引号之前的内容作为属性值
          value = context.source.slice(0, endQuoteIndex);
          // 消费属性值
          advanceBy(value.length);
          // 消费引号
          advanceBy(1);
        } else {
          // 缺少引号错误
          console.error("缺少引号");
        }
      } else {
        // 运行到这里，说明属性值没有被引号引用
        // 下一个空白字符之前的内容全部作为属性值
        const match = /^[^\t\r\n\f >]+/.exec(context.source);
        // 获取属性值
        value = match[0];
        // 消费属性值
        advanceBy(value.length);
      }
      // 消费属性值后面的空白字符
      advanceSpaces();

      // 使用属性名称 + 属性值创建一个属性节点，添加到 props 数组中
      props.push({ type: "Attribute", name, value });
    }
    return props;
  }

  console.log("parse--", parse(`<div id ='foo' v-show ='display' ></div>`));
</script>
